In the given project data, we firstly recognize ’area’, ’artist’ and ’genre’ each as three individual entities. Each artist is from at most one area, so it’s a many-to-one relation. Several artists can belong to different genres and one genre can contain several artists. So the relation between ’artist’ and ’genre’ is many-to-many.Secondly, we think about the relationship among ’release’,’recording’,track’ and ’medium’. We imagine a scene to describe these relations. The csv file of ’release’ contains the names of releases. They could be stored in the mediums, such as CD, 12” Vinyl and so on. What’s more, one release could have several CDs to contain many tracks, or in different medium (I’m not sure about this, but possible). So the relation between ’release’ and ’medium’ is one-to-many. Next, each track in different mediums must correspond to one recording. So the relation between ’track’ and ’recording’ is many-to-one. Each ’track’ must be in one of ’medium’s. So the relation is many-to-one.Finally, we merge one-to-may relations. ‘release’ and ‘medium’ are merged into ‘Release_medium’.  ‘area’ can be merged into ‘artist’ as attributes. The ‘has’ relation between ’Release_medium’ and ‘track’ is merged into ‘track’ using ‘mid’ as foreign key. So is the ‘copy’ relation between ‘recording’ and ‘track’ using ‘id’ of recording as foreign key.
Additionally, we ignore the ‘count’ in ‘genre’, which could be created as view in the database.